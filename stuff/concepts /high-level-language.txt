# high level language planning / documentation

here goes i guess, this is going to be the hardest part of this entire project but it will be necessary in order to be able to program effectively for the environment


CY++ high level programming language specs / programming style:

    - object and class oriented,
        - each class will be compiled separately into a separate assembly code file, then they will be combined together into a working program / executable.
        - a class will consist of several functions including a function labelled "Default" which when compiled into assembly will be placed at the top to execute first
          in the program.
        - one class must be labelled "main" and this class will be put in a file called main.txt and will always execute first on the vm based architecture
        - all of the other classes will be compiled into the same directory, with the name of the class that it contains.
        - when this is compiled to binary, we could either have a dynamic memory allocator on the system that will make the variable locations for each running class relative
          or we could make it so that all of the class files when compiled to binary are put into one file. this would make the most sense as it would eliminate the need 
          for custom hardware and extra assembly commands / processes just to allocate memory for each class when we can unify the program at a later stage.
        - separating into classes means that we can have a separate abstract syntax tree for each class / function, this simplifys things since we are dealing with less
          complex logic / algorithms, essentially decomposing the problem into multiple diffrent low level programs that are all compiled together into binary

    - static variable declaration
        - to keep memory management simple for the computer to handle (remember we are dealing with an architecture that could run on a redstone comuter, many of which
          run at well under 1Hz, with 1Hz being an impressive achievement even for efficient hardware)
        - it means that we have to declare the type of the variable before we assign anything to it. this makes memory management easier like ive previously stated but
          can result in some inconvenience for users that are more used to more dynamic languages like python



the language / syntax:

    - calling variables / functions
        - examples of all syntax explained here will be given under this section
        - an in-built function will be called with the "$" symbol whereas a user defined function will be called with "@" in reference to the function.
        

        



examples:

    - hello world

        $output(STR "hello world")

        - "$output" is the inbuilt method for outputting to console
        - the string "hello there" is declared using the "STR" keyword to its left
        - the brackets that are to the right of the output function contain everything that is to be outputted

        - assembly equivalent:

        VAR [STR "hello world" -> 01]
        LDA [01 -> REG-1]
        OUT [REG-1]



    - basic program with a class:

        class main():
            function default():
                INT x = 1 + 1
                $output(x)



        - assembly equivalent:


        


        END []